const char box_http_lua[] =
"-- box.http\n"
"\n"
"(function(box)\n"
"    local function errorf(fmt, ...)\n"
"        error(string.format(fmt, ...))\n"
"    end\n"
"\n"
"    local function retcode(code, reason)\n"
"        return {\n"
"            status  = code,\n"
"            reason  = reason\n"
"        }\n"
"    end\n"
"\n"
"    local function connect(host, port)\n"
"        local s = box.socket.tcp()\n"
"        if s == nil then\n"
"            return nil, \"Can't create socket\"\n"
"        end\n"
"        local res = { s:connect(host, port) }\n"
"        if res[1] == nil then\n"
"            return nil, res[4]\n"
"        end\n"
"        return s\n"
"    end\n"
"\n"
"    local function drop_connection(host, port, socket, close)\n"
"        -- TODO cache connections\n"
"\n"
"        socket:close()\n"
"    end\n"
"\n"
"\n"
"    local function ucfirst(str)\n"
"        return (str:gsub(\"^%l\", string.upper))\n"
"    end\n"
"\n"
"\n"
"    box.http = {\n"
"        request = function(method, url, hdrs, body)\n"
"            if hdrs == nil then\n"
"                hdrs = {}\n"
"            end\n"
"\n"
"            local ho = {}\n"
"            for k, v in pairs(hdrs) do\n"
"                ho[ string.lower(k) ] = v\n"
"            end\n"
"            hdrs = ho\n"
"            ho = nil\n"
"\n"
"            method = string.upper(method)\n"
"\n"
"            if method ~= 'GET' and method ~= 'POST' then\n"
"                return retcode(599, \"Unknown request method: \" .. method)\n"
"            end\n"
"\n"
"            local scheme, host, port, path, query = box.http.split_url( url )\n"
"\n"
"            if scheme ~= 'http' then\n"
"                return retcode(599, \"Unknown scheme: \" .. scheme)\n"
"            end\n"
"\n"
"            if string.len(host) < 1 then\n"
"                return retcode(595, \"Can't route host\")\n"
"            end\n"
"\n"
"            if port == nil then\n"
"                port = 80\n"
"            elseif string.match(port, '^%d+$') ~= nil then\n"
"                    port = tonumber(port)\n"
"            else\n"
"                return retcode(599, \"Wrong port number: \" .. port)\n"
"            end\n"
"\n"
"            local s, err = connect(host, port)\n"
"            if s == nil then\n"
"                return retcode(595, err)\n"
"            end\n"
"\n"
"\n"
"            if body == nil then\n"
"                body = ''\n"
"            end\n"
"\n"
"            if method == 'GET' then\n"
"                hdrs['content-length'] = nil\n"
"                body = ''\n"
"            elseif string.len(body) > 0 then\n"
"                hdrs['content-length'] = string.len(body)\n"
"            end\n"
"\n"
"            if hdrs['user-agent'] == nil then\n"
"                hdrs['user-agent'] = 'Tarantool box.http agent'\n"
"            end\n"
"\n"
"            if port == 80 then\n"
"                hdrs['host'] = host\n"
"            else\n"
"                hdrs['host'] = string.format(\"%s:%d\", host, port)\n"
"            end\n"
"\n"
"            hdrs['connection'] = 'keep-alive'\n"
"            if hdrs['te'] == nil then\n"
"                hdrs['te'] = 'trailers'\n"
"            end\n"
"\n"
"            if hdrs.referer == nil then\n"
"                hdrs.referer = url\n"
"            end\n"
"\n"
"            hdrs.URL = url\n"
"            \n"
"            \n"
"            local hdr = ''\n"
"            for i, v in pairs(hdrs) do\n"
"                hdr = hdr .. string.format(\"%s: %s\\r\\n\", ucfirst(i), v)\n"
"            end\n"
"\n"
"            local pquery = ''\n"
"\n"
"            if string.len(query) > 0 then\n"
"                pquery = '?' .. query\n"
"            end\n"
"\n"
"\n"
"            local req = string.format(\n"
"                \"%s %s%s HTTP/1.1\\r\\n%s\\r\\n%s\",\n"
"\n"
"                    method,\n"
"                    path,\n"
"                    pquery,\n"
"                    hdr,\n"
"                    body\n"
"            )\n"
"\n"
"\n"
"            local res = { s:send(req) }\n"
"\n"
"            if #res > 1 then\n"
"                return retcode(595, res[4])\n"
"            end\n"
"            if res[1] ~= string.len(req) then\n"
"                return retcode(595, \"Can't send request\")\n"
"            end\n"
"\n"
"\n"
"            res = { s:readline({ \"\\n\\n\", \"\\r\\n\\r\\n\" }) }\n"
"\n"
"            if res[2] ~= nil and res[2] ~= 'eof' then\n"
"                -- TODO: text of error\n"
"                return retcode(595, \"Can't read response headers\")\n"
"            end\n"
"            \n"
"            local resp = box.http.parse_response(res[1])\n"
"\n"
"            if resp.error ~= nil then\n"
"                return retcode(595, resp.error)\n"
"            end\n"
"\n"
"            resp.body = ''\n"
"            if resp.headers['content-length'] ~= nil then\n"
"                res = { s:recv(tonumber(resp.headers['content-length'])) }\n"
"                if #res > 1 then\n"
"                    -- TODO: text of error\n"
"                    return retcode(595, \"Can't read response body\")\n"
"                end\n"
"            end\n"
"\n"
"            resp.body = res[1]\n"
"\n"
"            drop_connection(host, port, s)\n"
"\n"
"--             print(\" - '\" .. box.cjson.encode(hdrs) .. \"'\")\n"
"            return resp\n"
"        end\n"
"    }\n"
"end)(box)\n"
"\n"
""
;
