const char box_httpd_lua[] =
"-- box.httpd\n"
"\n"
"(function(box)\n"
"    print(\"Plugin box.httpd init...\")\n"
"\n"
"    local ffi = require(\"ffi\")\n"
"\n"
"    local function errorf(fmt, ...)\n"
"        error(string.format(fmt, ...))\n"
"    end\n"
"    local function printf(fmt, ...)\n"
"        print(string.format(fmt, ...))\n"
"    end\n"
"\n"
"    local function extend(tbl, tblu)\n"
"        local res = {}\n"
"        for k, v in pairs(tbl) do\n"
"            res[ k ] = v\n"
"        end\n"
"        for k, v in pairs(tblu) do\n"
"            if res[ k ] == nil then\n"
"                errorf(\"Unknown option '%s'\", k)\n"
"            end\n"
"            res[ k ] = v\n"
"        end\n"
"        return res\n"
"    end\n"
"\n"
"\n"
"    function log(peer, code, req, len)\n"
"        if req == nil then\n"
"            len = 0\n"
"            req = '-'\n"
"        else\n"
"            if len == nil then\n"
"                len = 0\n"
"            end\n"
"        end\n"
"\n"
"        printf(\"%s - - \\\"%s\\\" %s %s\\n\", peer, req, code, len)\n"
"    end\n"
"\n"
"    function hlog(peer, code, hdr)\n"
"        if string.len(hdr) == 0 then\n"
"            return log(peer, code)\n"
"        end\n"
"        local rs = string.match(hdr, \"^(.-)[\\r\\n]\")\n"
"        if rs == nil then\n"
"            return log(peer, code, hdr)\n"
"        else\n"
"            return log(peer, code, rs)\n"
"        end\n"
"    end\n"
"\n"
"\n"
"    local function process_client(self, s, peer)\n"
"        box.fiber.wrap(function()\n"
"\n"
"            printf('box.httpd: accepted connection %s', peer)\n"
"\n"
"            local hdrs = {\n"
"                s:readline(\n"
"                    self.options.max_header_size,\n"
"                    { \"\\n\\n\", \"\\r\\n\\r\\n\" }\n"
"--                     self.options.header_timeout\n"
"                )\n"
"            }\n"
"\n"
"            if hdrs[2] == 'limit' then\n"
"                hlog(peer, 400, hdrs[1])\n"
"                s:close()\n"
"                return\n"
"            end\n"
"            if hdrs[2] ~= nil then\n"
"                printf(\"Error while reading headers: %s, %s\", hdrs[4], hdrs[2])\n"
"                s:close()\n"
"                return\n"
"            end\n"
"\n"
"            hlog(peer, 222, hdrs[1])\n"
"\n"
"            s:send(\"aaaaaaaaaaaaa\\n\")\n"
"            s:send(\"aaaaaaaaaaaaa\\n\")\n"
"            s:close()\n"
"        end)\n"
"    end\n"
"\n"
"\n"
"    local function httpd_start(self)\n"
"        if type(self) ~= 'table' then\n"
"            error(\"box.httpd: usage: httpd:start()\")\n"
"        end\n"
"        local s = box.socket.tcp()\n"
"        if s == nil then\n"
"            error(\"Can't create new tcp socket\")\n"
"        end\n"
"\n"
"\n"
"        local res = { s:bind(self.host, self.port) }\n"
"        if res[1] == 'error' then\n"
"            errorf(\"Can't bind socket: %s\", res[3])\n"
"        end\n"
"\n"
"        res = { s:listen() }\n"
"        if res[1] == 'error' then\n"
"            errorf(\"Can't listen socket: %s\", res[3])\n"
"        end\n"
"\n"
"        rawset(self, 'is_run', true)\n"
"        rawset(self, 's', s)\n"
"\n"
"        box.fiber.wrap(function()\n"
"            printf('box.httpd: started at host=%s, port=%s',\n"
"                self.host, self.port)\n"
"            while self.is_run do\n"
"                local cs, status, es = s:accept(.5)\n"
"                if cs == 'error' then\n"
"                    printf(\"Can't accept socket: %s\", es)\n"
"                    break\n"
"                elseif cs ~= 'timeout' then\n"
"                    process_client(self, cs, es)\n"
"                    cs = nil\n"
"                end\n"
"            end\n"
"            self.s:close()\n"
"            rawset(self, 's', nil)\n"
"            rawset(self, 'is_run', false)\n"
"        end)\n"
"\n"
"    end\n"
"\n"
"\n"
"    box.httpd = {\n"
"        new = function(host, port, options)\n"
"            if options == nil then\n"
"                options = {}\n"
"            end\n"
"            if type(options) ~= 'table' then\n"
"                errorf(\"options must be table not '%s'\", type(options))\n"
"            end\n"
"            local default = {\n"
"                max_header_size     = 4096,\n"
"                max_headers         = 128,\n"
"\n"
"                max_fibers          = 1024,\n"
"                header_timeout      = 100\n"
"            }\n"
"            local self = {\n"
"                host    = host,\n"
"                port    = port,\n"
"                is_run  = false,\n"
"                stop    = function() error(\"http server is not started\") end,\n"
"                start   = httpd_start,\n"
"                options = extend(default, options)\n"
"            }\n"
"\n"
"            return self\n"
"        end\n"
"    }\n"
"\n"
"\n"
"end)(box)\n"
"\n"
""
;
